apply plugin: 'base'
apply from: '../common.gradle'

if (!hasProperty('unityExecutable'))
	ext { unityExecutable = '/Applications/Unity/Unity.app/Contents/MacOS/Unity' }

def unityProject = file("$buildDir/project")

def scriptFile = new File(unityProject, 'Assets/Editor/Logger.js')
scriptFile.parentFile.mkdirs()
scriptFile.text = '''
import System.Linq;
import System.IO;

static function LogAll() {
  Log(Path.GetDirectoryName(typeof(UnityEngine.Object).Assembly.Location));

  Log(Application.unityVersion);

  //var editorReferences = typeof(UnityEditor.EditorApplication).Assembly.GetReferencedAssemblies();
  //for (var editorRef in editorReferences) Log(editorRef);
  //Log(editorReferences.Single(function(assemblyName) { return assemblyName.Name == 'ICSharpCode.NRefactory'; }).Version);
}

static function Log(o) {
	Debug.Log("(" + o + ")");
}
'''

def logFile = file("$buildDir/unityLog.txt")

project.exec {
	commandLine unityExecutable
	args '-batchMode'
	args '-quit'
	args '-projectPath'
	args unityProject
	args '-executeMethod'
	args 'Logger.LogAll'
	args '-cleanedLogFile'
	args logFile
}

def pattern = ~/\((.+?)\)/
def log = logFile.text
def matches = pattern.matcher(log).collect { it[1] }

def unityLibsDir = matches[0]
def unityVersion = matches[1]

subprojects {

	version = unityVersion
	group = 'Unity'

	configurations {
		editor
	}

	apply plugin: 'base'

	task publish(dependsOn: uploadEditor)

	task zip(type: Zip) {
		from unityLibsDir
		include "${project.name}.dll"
	}

	artifacts {
		editor zip
	}

	tasks.uploadEditor {
		repositories {
			ivy { url repositoryForPublishing }
		}
	}
}

configurations {
	editor
}

dependencies {
	subprojects.each {
		editor project(path: it.path, configuration: 'editor')
	}
}

project(':UnityEditor') {
	dependencies {
		[':UnityEngine', ':ICSharpCode.NRefactory'].each {
			editor project(path: it, configuration: 'editor')
		}
	}
}